# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CatastoIT_GML_Merger_Pro
                                 A QGIS plugin CatastoIT_GML_Merger_Pro
                                 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-02-10
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Salvatore Fiandaca
        email                : pigrecoinfinito@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QApplication, QListWidget
from qgis.core import Qgis, QgsVectorLayer, QgsProject, QgsMessageLog, QgsField

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .catasto_gml_merger_dialog import catasto_gml_mergerDialog
import os.path

import os
import tempfile
import shutil
import urllib.request
from zipfile import ZipFile
import processing
import time
import gc
from datetime import datetime, timedelta
import io  # Aggiungilo alle altre importazioni all'inizio del file

directory_temporanea = ""                


class catasto_gml_merger:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'catasto_gml_merger_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Catasto_gml_merger')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('catasto_gml_merger', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/catasto_gml_merger/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'catasto_gml_merger'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Catasto_gml_merger'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        if self.first_start == True:
            self.first_start = False
            self.dlg = catasto_gml_mergerDialog()
            
            # La checkbox cb_filter_province (riga 3) e la combobox cb_province (riga 4) 
            # sono gi√† definite nell'UI, dobbiamo solo configurarle

        self.dlg.show()

            
        def log_message(msg):
            print(msg)
            QgsMessageLog.logMessage(msg, 'Elaborazione GML')
            self.dlg.text_log.append(msg)
            self.dlg.text_log.repaint()
            
        def collect_inputs():
            inputs = {}
            
            file_type = self.dlg.cb_file_type.currentText()
            inputs['file_type'] = file_type
            print(inputs['file_type'])
            
            inputs['main_folder'] = self.dlg.le_folder.filePath()
            print(inputs['main_folder'])
            
            # Verifica che sia stata selezionata una cartella di lavoro
            if not inputs['main_folder']:
                log_message("ERRORE: Nessuna cartella di lavoro selezionata")
                return None
            
            inputs['url'] = self.dlg.le_url.text()
            print(inputs['url'])
            
            # Ottieni le province selezionate dalla list_provinces
            selected_items = self.dlg.list_provinces.selectedItems()
            if not selected_items:
                log_message("ERRORE: Nessuna provincia selezionata")
                return None
            
            # Crea una lista di codici provincia dalle selezioni
            province_codes = [item.text().strip().upper() for item in selected_items]
            inputs['province_code'] = ','.join(province_codes)
            inputs['filter_by_province'] = True
            
            log_message(f"Province selezionate: {inputs['province_code']}")
            print(f"Province selezionate: {inputs['province_code']}")
            
            formats = {
                'GPKG': '.gpkg'
            }

            format_name = self.dlg.cb_format.currentText()
            inputs['format_name'] = format_name
            inputs['output_extension'] = formats[format_name]
            print(inputs['output_extension'])
            
            if file_type in ['Mappe (MAP)', 'Entrambi']:
                map_output = self.dlg.le_map_output.filePath()                                      
                if not map_output: return None
                if not map_output.endswith(formats[format_name]):
                    map_output += formats[format_name]
                inputs['map_output'] = map_output
                print(inputs['map_output'])
            
            if file_type in ['Particelle (PLE)', 'Entrambi']:
                ple_output = self.dlg.le_ple_output.filePath()                                        
                if not ple_output: return None
                if not ple_output.endswith(formats[format_name]):
                    ple_output += formats[format_name]
                inputs['ple_output'] = ple_output
                print(inputs['ple_output'])

            inputs['load_layers'] = self.dlg.cb_load_layers.isChecked()
            print(inputs['load_layers'])
            
            self.dlg.text_log.clear()
            
            return inputs

        def merge_files(source_folder, output_file, file_type, inputs):
            start_time = datetime.now()

            source_files = [
                os.path.join(source_folder, f)
                for f in os.listdir(source_folder)
                if f.endswith(".gml")
            ]

            if source_files:
                # Usa una directory temporanea specifica per evitare conflitti
                temp_dir = os.path.join(os.path.dirname(source_folder), "temp_processing")
                os.makedirs(temp_dir, exist_ok=True)
                temp_merge = os.path.join(temp_dir, f"temp_merge_{file_type}_{int(time.time())}.gpkg")

                # Verifica directory di output e creala se necessario
                output_dir = os.path.dirname(output_file)
                if output_dir and not os.path.exists(output_dir):
                    try:
                        os.makedirs(output_dir, exist_ok=True)
                        log_message(f"Directory di output creata: {output_dir}")
                    except Exception as e:
                        log_message(f"ERRORE: Impossibile creare la directory di output: {str(e)}")
                        return None

                # Verifica che la cartella di output sia scrivibile
                try:
                    test_file = os.path.join(output_dir, "test_write.tmp")
                    with open(test_file, 'w') as f:
                        f.write("test")
                    os.remove(test_file)
                except Exception as e:
                    log_message(f"ERRORE: La directory di output non √® scrivibile: {str(e)}")
                    return None

                try:
                    # Chiudi eventuali layer aperti che potrebbero bloccare il file di output
                    project = QgsProject.instance()
                    layers_to_remove = []
                    for layer_id, layer in project.mapLayers().items():
                        if output_file in layer.source() or temp_merge in layer.source():
                            layers_to_remove.append(layer_id)
                    
                    for layer_id in layers_to_remove:
                        project.removeMapLayer(layer_id)
                    
                    # Rimuovi il file di output se esiste gi√†
                    if os.path.exists(output_file):
                        try:
                            os.remove(output_file)
                            log_message(f"File di output esistente rimosso: {output_file}")
                        except Exception as e:
                            log_message(f"ATTENZIONE: Impossibile rimuovere il file di output esistente: {str(e)}")
                            # Modifica il nome del file per evitare conflitti
                            base_name = os.path.splitext(output_file)[0]
                            ext = os.path.splitext(output_file)[1]
                            output_file = f"{base_name}_{int(time.time())}{ext}"
                            log_message(f"Usando nome file alternativo: {output_file}")

                    # Forza il garbage collection prima di operazioni critiche
                    gc.collect()
                    time.sleep(0.5)

                    merge_params = {
                        "LAYERS": source_files,
                        "CRS": None,
                        "OUTPUT": temp_merge,
                    }

                    log_message(f"Unione file {file_type}...")
                    processing.run("native:mergevectorlayers", merge_params)

                    # Chiudi esplicitamente i riferimenti ai layer che potrebbero utilizzare il file temporaneo
                    project = QgsProject.instance()
                    layers_to_remove = []
                    for layer_id, layer in project.mapLayers().items():
                        if temp_merge in layer.source():
                            layers_to_remove.append(layer_id)
                    
                    for layer_id in layers_to_remove:
                        project.removeMapLayer(layer_id)
                    
                    # Forza il garbage collection
                    gc.collect()
                    time.sleep(0.5)

                    # Assicurati sempre che la directory esista, indipendentemente dal formato
                    output_dir = os.path.dirname(output_file)
                    if output_dir and not os.path.exists(output_dir):
                        os.makedirs(output_dir, exist_ok=True)

                    # Processo semplificato: filtro direttamente nel formato desiderato (GPKG o GeoJSON)
                    filter_params = {
                        "INPUT": temp_merge,
                        "FIELDS": ["fid", "gml_id", "ADMINISTRATIVEUNIT"],
                        "OUTPUT": output_file
                    }

                    log_message(f"Filtro attributi per {file_type}...")
                    result = processing.run("native:retainfields", filter_params)
                    output_file = result['OUTPUT']

                    # Ottimizzazione della generazione dei campi utilizzando operazioni in batch
                    log_message(f"Aggiunta campo 'foglio' al layer {file_type}...")
                    output_layer = QgsVectorLayer(output_file, f"{file_type}_Uniti", "ogr")
                    
                    if output_layer.isValid():
                        # Prepara tutti i campi da aggiungere in una singola operazione
                        fields_to_add = [QgsField("foglio", QVariant.String)]
                        if file_type == "PLE":
                            log_message("Aggiunta campo 'particella'...")
                            fields_to_add.append(QgsField("particella", QVariant.String))
                        
                        # Inizia la transazione per le modifiche in batch
                        output_layer.startEditing()
                        output_layer.dataProvider().addAttributes(fields_to_add)
                        output_layer.updateFields()
                        
                        # Ottieni gli indici una sola volta fuori dal ciclo
                        foglio_idx = output_layer.fields().indexFromName("foglio")
                        particella_idx = output_layer.fields().indexFromName("particella") if file_type == "PLE" else -1
                        gml_id_idx = output_layer.fields().indexFromName("gml_id")
                        
                        # Calcola valori una sola volta
                        needs_particella = file_type == "PLE" and particella_idx >= 0
                        
                        # Inizializza il buffer per le modifiche prima di usarlo
                        changes_buffer = {}
                        
                        # Usa una singola passata per elaborare tutti i dati
                        for feature in output_layer.getFeatures():
                            feature_id = feature.id()
                            gml_id = feature[gml_id_idx]
                            
                            # Estrai foglio (posizioni 32-36) con controllo pi√π efficiente
                            if len(gml_id) > 36:
                                foglio = gml_id[32:36]
                                changes_buffer[feature_id] = {foglio_idx: foglio}
                                
                                # Estrai particella per PLE (dalla posizione 39 in poi)
                                # solo se necessario e se la stringa √® abbastanza lunga
                                if needs_particella and len(gml_id) > 39:
                                    particella = gml_id[39:]
                                    changes_buffer[feature_id][particella_idx] = particella
                        
                        # Rimosso il secondo ciclo duplicato che faceva lo stesso lavoro
                        
                        # Applica tutte le modifiche in batch
                        batch_size = 5000  # Dimensione del batch per evitare operazioni troppo grandi
                        batch_count = 0
                        for feature_id, attrs in changes_buffer.items():
                            for field_idx, value in attrs.items():
                                output_layer.changeAttributeValue(feature_id, field_idx, value)
                            
                            batch_count += 1
                            if batch_count % batch_size == 0:
                                # Aggiorna periodicamente l'interfaccia per mostrare progresso
                                QCoreApplication.processEvents()
                        
                        # Finalizza le modifiche e controlla errori
                        success = output_layer.commitChanges()
                        if success:
                            log_message(f"Campi calcolati correttamente per il layer {file_type}")
                        else:
                            log_message(f"ERRORE: Impossibile aggiornare i campi per il layer {file_type}")
                            log_message(str(output_layer.commitErrors()))
                    else:
                        log_message(f"ERRORE: Il layer di output {file_type} non √® valido")

                    # Pulizia risorse temporanee in modo pi√π robusto
                    try:
                        # Prima rilascia i riferimenti QGIS al file
                        for layer_id, layer in list(QgsProject.instance().mapLayers().items()):
                            if temp_merge in layer.source():
                                QgsProject.instance().removeMapLayer(layer_id)
                        
                        # Libera memoria e dai tempo al sistema
                        output_layer = None
                        gc.collect()
                        time.sleep(1)
                        
                        # Ora prova a cancellare i file temporanei
                        if os.path.exists(temp_merge):
                            try:
                                os.remove(temp_merge)
                                log_message(f"File temporaneo rimosso: {os.path.basename(temp_merge)}")
                            except Exception as e:
                                log_message(f"Impossibile rimuovere il file temporaneo: {str(e)}")
                        
                        # Rimuovi anche la directory temporanea se vuota
                        if os.path.exists(temp_dir) and len(os.listdir(temp_dir)) == 0:
                            os.rmdir(temp_dir)
                            log_message("Directory temporanea rimossa")
                    except Exception as e:
                        log_message(f"Nota: Impossibile rimuovere alcuni file temporanei: {str(e)}")
                        log_message("<span style='color:#FF8C00;font-weight:bold;'>I file temporanei verranno rimossi alla chiusura del Plugin</span>")
                    
                    # Carica i layer se richiesto
                    if inputs["load_layers"]:
                        # Aggiungi un avviso chiaro sui file temporanei
                        log_message("<span style='color:#FF8C00;font-weight:bold;'>I file temporanei saranno ELIMINATI dopo la conclusione del Processo pigiando sul bottone Pulisci!</span>")
                        
                        # Ottieni il nome del file senza percorso e estensione
                        file_name = os.path.basename(output_file)
                        base_name = os.path.splitext(file_name)[0]
                        
                        merged_layer = QgsVectorLayer(output_file, base_name, "ogr")
                        if merged_layer.isValid():
                            QgsProject.instance().addMapLayer(merged_layer)
                            log_message(f"Layer {base_name} caricato in QGIS")
                        else:
                            log_message(f"ERRORE: Impossibile caricare il layer {base_name}")
                                
                    end_time = datetime.now()
                    
                    # Aggiungi questo per aggiornare gli input con i percorsi di output corretti
                    if file_type == "MAP" and "map_output" in inputs:
                        inputs["map_output"] = output_file
                    elif file_type == "PLE" and "ple_output" in inputs:
                        inputs["ple_output"] = output_file
                    
                    return end_time - start_time

                except Exception as e:
                    log_message(f"ERRORE: Si √® verificato un problema durante l'unione dei file: {str(e)}")
                    # Aggiungi traceback per debugging
                    import traceback
                    log_message(f"Dettagli: {traceback.format_exc()}")
                    return None

            return None

        def process_gml_files():
            global directory_temporanea
            temp_dir = None
            
            # Imposta il cursore di attesa
            QApplication.setOverrideCursor(Qt.WaitCursor)
            
            try:
                # Inizializza lo stato di elaborazione
                self.processing_active = True
                
                # Abilita il pulsante di stop e disabilita quello di processo
                self.dlg.btn_stop.setEnabled(True)
                self.dlg.btn_process.setEnabled(False)
                
                # Inizializza la progress bar
                self.dlg.progressBar.setValue(0)
                self.dlg.progressBar.setVisible(True)
                
                inputs = collect_inputs()
                if not inputs or not self.processing_active:
                    log_message("Operazione annullata")
                    QApplication.restoreOverrideCursor()
                    self.dlg.progressBar.setVisible(False)
                    self.reset_processing_state()
                    return
                
                # Creiamo una directory temporanea minima
                temp_dir = tempfile.mkdtemp()
                directory_temporanea = temp_dir
                self.dlg.setWindowTitle("CatastoIT GML Merger - Elaborazione in corso")
                
                # Crea le cartelle di output per i file GML solo al bisogno
                map_folder = os.path.join(temp_dir, "map_files")
                ple_folder = os.path.join(temp_dir, "ple_files")
                
                if inputs["file_type"] in ["Mappe (MAP)", "Entrambi"]:
                    os.makedirs(map_folder, exist_ok=True)
                
                if inputs["file_type"] in ["Particelle (PLE)", "Entrambi"]:
                    os.makedirs(ple_folder, exist_ok=True)
                
                # Download del file zip principale
                log_message(f"Directory temporanea creata: {temp_dir}\n")
                log_message("Download del file zip principale...\n")
                
                self.dlg.progressBar.setValue(5)  # 5% dopo inizializzazione
                
                main_zip_path = os.path.join(temp_dir, "downloaded.zip")
                urllib.request.urlretrieve(inputs["url"], main_zip_path)
                
                self.dlg.progressBar.setValue(15)  # 15% dopo download

                # Filtra per provincia
                province_codes = [p.strip().upper() for p in inputs['province_code'].split(',')]
                log_message(f"Province selezionate: {', '.join(province_codes)}")
                
                # Modifica il nome dell'output con tutti i codici provincia
                province_suffix = "_".join(province_codes)
                if inputs["file_type"] in ["Mappe (MAP)", "Entrambi"]:
                    base_name = os.path.splitext(inputs["map_output"])[0]
                    ext = os.path.splitext(inputs["map_output"])[1]
                    inputs["map_output"] = f"{base_name}_{province_suffix}{ext}"
                    log_message(f"Output MAP aggiornato: {inputs['map_output']}")
                
                if inputs["file_type"] in ["Particelle (PLE)", "Entrambi"]:
                    base_name = os.path.splitext(inputs["ple_output"])[0]
                    ext = os.path.splitext(inputs["ple_output"])[1]
                    inputs["ple_output"] = f"{base_name}_{province_suffix}{ext}"
                    log_message(f"Output PLE aggiornato: {inputs['ple_output']}")

                # Contatori per i file
                ple_count = map_count = 0
                
                # Usa un buffer di memoria per i nomi dei file estratti per evitare duplicazioni
                extracted_files = set()
                
                # Gestione dei file ZIP annidati
                log_message("Elaborazione file...")
                
                self.dlg.progressBar.setValue(20)  # 20% prima dell'estrazione
                
                with ZipFile(main_zip_path, "r") as main_zip:
                    # Estrai solo l'elenco dei file, non il contenuto
                    province_zips = [f for f in main_zip.namelist() if f.endswith('.zip')]
                    
                    # Filtra per province selezionate
                    filtered_province_zips = []
                    for prov_zip in province_zips:
                        prov_name = os.path.basename(prov_zip)
                        for code in province_codes:
                            if code in prov_name.upper():
                                filtered_province_zips.append(prov_zip)
                                log_message(f"Provincia trovata: {prov_name}")
                                break
                    
                    if not filtered_province_zips:
                        log_message(f"ATTENZIONE: Nessuna provincia trovata con i codici '{inputs['province_code']}'")
                        log_message("Controlla che i codici provincia siano corretti e riprova")
                        self.dlg.progressBar.setVisible(False)
                        return
                    
                    # Processa ogni provincia selezionata
                    total_provinces = len(filtered_province_zips)
                    
                    for idx, prov_zip_path in enumerate(filtered_province_zips):
                        prov_progress_base = 20  # Iniziamo dal 20%
                        prov_progress_range = 30  # Le province coprono il 30% dell'avanzamento totale
                        prov_progress = prov_progress_base + (idx / total_provinces) * prov_progress_range
                        self.dlg.progressBar.setValue(int(prov_progress))
                        
                        prov_name = os.path.basename(prov_zip_path)
                        log_message(f"Elaborazione provincia: {prov_name}")
                        
                        # Estrai il file ZIP della provincia in un BytesIO per processarlo in memoria
                        with main_zip.open(prov_zip_path) as prov_zip_file:
                            prov_zip_data = io.BytesIO(prov_zip_file.read())
                            
                            with ZipFile(prov_zip_data) as prov_zip:
                                comuni_zips = [f for f in prov_zip.namelist() if f.endswith('.zip')]
                                
                                # Calcola il totale dei comuni per la barra di progresso
                                total_comuni = len(comuni_zips)
                                processed_comuni = 0
                                
                                for com_zip_path in comuni_zips:
                                    if not self.processing_active:
                                        log_message("Elaborazione interrotta dall'utente")
                                        break
                                    
                                    com_name = os.path.basename(com_zip_path)
                                    processed_comuni += 1
                                    
                                    # Calcola progresso per i comuni all'interno della provincia
                                    comuni_progress = prov_progress + (processed_comuni / total_comuni) * (prov_progress_range / total_provinces)
                                    if processed_comuni % 10 == 0 or processed_comuni == total_comuni:
                                        self.dlg.progressBar.setValue(int(comuni_progress))
                                        log_message(f"Elaborazione comune {processed_comuni}/{total_comuni}: {com_name}")
                                        QCoreApplication.processEvents()
                                    
                                    # Estrai il file ZIP del comune in un BytesIO
                                    with prov_zip.open(com_zip_path) as com_zip_file:
                                        com_zip_data = io.BytesIO(com_zip_file.read())
                                        
                                        with ZipFile(com_zip_data) as com_zip:
                                            gml_files = [f for f in com_zip.namelist() if f.endswith('.gml')]
                                            
                                            # Estrai solo i file GML richiesti
                                            for gml_file in gml_files:
                                                file_name = os.path.basename(gml_file)
                                                
                                                # Verifica se il file √® gi√† stato estratto (evita duplicati)
                                                if file_name in extracted_files:
                                                    continue
                                                    
                                                # Verifica il tipo di file e se √® richiesto
                                                is_ple = "_ple" in file_name.lower()
                                                is_map = "_map" in file_name.lower()
                                                
                                                if (is_ple and inputs["file_type"] in ["Particelle (PLE)", "Entrambi"]) or \
                                                   (is_map and inputs["file_type"] in ["Mappe (MAP)", "Entrambi"]):
                                                    
                                                    # Determina la cartella di destinazione
                                                    dest_folder = ple_folder if is_ple else map_folder
                                                    dest_path = os.path.join(dest_folder, file_name)
                                                    
                                                    # Estrai il file nella cartella appropriata
                                                    with com_zip.open(gml_file) as source, \
                                                         open(dest_path, 'wb') as target:
                                                        shutil.copyfileobj(source, target)
                                                    
                                                    # Aggiorna contatori
                                                    if is_ple:
                                                        ple_count += 1
                                                    else:
                                                        map_count += 1
                                                    
                                                    # Aggiungi al set per evitare duplicati
                                                    extracted_files.add(file_name)
                
                log_message(f"\nFile estratti: {ple_count} PLE, {map_count} MAP")
                self.dlg.progressBar.setValue(50)  # 50% dopo estrazione
                
                # Libera memoria
                extracted_files.clear()
                gc.collect()
                
                # Esegui l'unione dei file
                processing_times = {}

                # Esegui l'unione una sola volta per tipo di file
                if inputs["file_type"] in ["Mappe (MAP)", "Entrambi"] and map_count > 0 and self.processing_active:
                    log_message("\nUnione files MAP\n")
                    map_time = merge_files(
                        map_folder, inputs["map_output"], "MAP", inputs
                    )
                    self.dlg.progressBar.setValue(75)  # 75% dopo unione MAP
                    if map_time:
                        processing_times["MAP"] = map_time

                if inputs["file_type"] in ["Particelle (PLE)", "Entrambi"] and ple_count > 0 and self.processing_active:
                    log_message("\nUnione files PLE\n")
                    log_message("<span style='color:blue;font-weight:bold;'>Attendere prego, operazione costosa! (potrebbe durare alcuni minuti)</span>")
                    ple_time = merge_files(
                        ple_folder, inputs["ple_output"], "PLE", inputs
                    )
                    # Se abbiamo gi√† elaborato MAP arriviamo al 100%, altrimenti al 75%
                    if inputs["file_type"] == "Entrambi":
                        self.dlg.progressBar.setValue(100)
                    else:
                        self.dlg.progressBar.setValue(75)
                        
                    if ple_time:
                        processing_times["PLE"] = ple_time 

                log_message("\nElaborazione completata!")
                self.dlg.progressBar.setValue(100)  # 100% a elaborazione completata
                
                if "map_output" in inputs and map_count > 0:
                    log_message(f"File MAP salvato in: {inputs['map_output']}")
                if "ple_output" in inputs and ple_count > 0:
                    log_message(f"File PLE salvato in: {inputs['ple_output']}")
                        
                log_message("\nTempi di elaborazione:")
                for file_type, proc_time in processing_times.items():
                    if proc_time:
                        minutes = proc_time.total_seconds() / 60
                        log_message(f"Merge {file_type}: {minutes:.2f} minuti")
                        
            except Exception as e:
                log_message(f"\nSi √® verificato un errore durante l'elaborazione: {str(e)}")
                import traceback
                log_message(f"\nDettagli errore:\n{traceback.format_exc()}")
                if temp_dir:
                    directory_temporanea = temp_dir  # Assegna anche in caso di errore
            finally:
                # Ripristina lo stato dell'interfaccia
                self.reset_processing_state()
                QApplication.restoreOverrideCursor()

        def pulisci_temporanea():
            global directory_temporanea
            dir_path = directory_temporanea
            
            # Reset della progress bar
            self.dlg.progressBar.setValue(0)
            self.dlg.progressBar.setVisible(False)
            
            if dir_path and os.path.exists(dir_path):
                # Libera tutti i layer che potrebbero usare file nella directory temporanea
                for layer_id, layer in list(QgsProject.instance().mapLayers().items()):
                    if dir_path in layer.source():
                        QgsProject.instance().removeMapLayer(layer_id)
                
                # Forza garbage collection
                gc.collect()
                time.sleep(1)
                
                try:
                    for root, dirs, files in os.walk(dir_path, topdown=False):
                        for file in files:
                            try:
                                os.remove(os.path.join(root, file))
                            except:
                                log_message(f"Impossibile rimuovere {file}")
                    
                    shutil.rmtree(dir_path)
                    log_message(f"Directory {dir_path} rimossa correttamente")
                except OSError as e:
                    log_message(f"\nErrore nella pulizia: {str(e)}")
                    log_message("Alcuni file temporanei verranno rimossi alla chiusura del Plugin")
            else:
                log_message("Nessuna directory temporanea da pulire")

            # Resetta l'interfaccia
            self.dlg.le_folder.setFilePath("")
            self.dlg.le_map_output.setFilePath("")
            self.dlg.le_ple_output.setFilePath("")
            self.dlg.cb_file_type.setCurrentIndex(0)
            self.dlg.cb_format.setCurrentIndex(0)
            self.dlg.cb_region.setCurrentIndex(0)
            self.dlg.list_provinces.clearSelection()  # Cancella le selezioni dalla lista
            self.dlg.cb_region.setEnabled(True)
            self.dlg.le_url.setEnabled(True)
            self.dlg.le_url.clear()
            self.dlg.text_log.clear()
            self.dlg.setWindowTitle("CatastoIT GML Merger")
            
            # Chiudi il dialog alla fine
            self.dlg.hide()

        def url_update():
            self.dlg.le_url.setText("https://wfs.cartografia.agenziaentrate.gov.it/inspire/wfs/GetDataset.php?dataset=" + self.dlg.cb_region.currentText() + ".zip")
            
        def aggiorna_campi_output():
            """Attiva o disattiva i campi di output in base al tipo di file selezionato"""
            file_type = self.dlg.cb_file_type.currentText()
            
            # Gestisci i widget per l'output MAP
            map_enabled = file_type in ["Mappe (MAP)", "Entrambi"]
            self.dlg.le_map_output.setEnabled(map_enabled)
            
            # Gestisci i widget per l'output PLE
            ple_enabled = file_type in ["Particelle (PLE)", "Entrambi"]
            self.dlg.le_ple_output.setEnabled(ple_enabled)
            
        self.dlg.cb_region.currentIndexChanged.connect(url_update)
        self.dlg.cb_file_type.currentIndexChanged.connect(aggiorna_campi_output)                                                       
        self.dlg.btn_process.clicked.connect(process_gml_files)
        self.dlg.btn_close.clicked.connect(pulisci_temporanea)
        self.dlg.btn_stop.clicked.connect(self.stop_processing)  # Ora funzioner√† correttamente
        self.dlg.btn_stop.setEnabled(False)  # Disabilitato all'avvio
        
        # Imposta lo stato iniziale dei campi di output
        aggiorna_campi_output()

    def stop_processing(self):
        """Interrompe il processo di elaborazione in corso"""
        if self.processing_active:
            self.processing_active = False
            # Utilizziamo la funzione log_message definita nel contesto di run()
            self.dlg.text_log.append("\n<span style='color:red;font-weight:bold;'>Interruzione richiesta dall'utente...</span>")
            self.dlg.text_log.append("L'elaborazione verr√† interrotta appena possibile")
            self.dlg.btn_stop.setEnabled(False)
    
    def reset_processing_state(self):
        """Ripristina lo stato dell'interfaccia dopo l'elaborazione"""
        self.processing_active = False
        self.dlg.btn_stop.setEnabled(False)
        self.dlg.btn_process.setEnabled(True)