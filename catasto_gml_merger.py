# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CatastoIT_GML_Merger_Pro
                                 A QGIS plugin CatastoIT_GML_Merger_Pro
                                 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-02-10
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Salvatore Fiandaca
        email                : pigrecoinfinito@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import Qgis, QgsVectorLayer, QgsProject, QgsMessageLog, QgsField

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .catasto_gml_merger_dialog import catasto_gml_mergerDialog
import os.path

import os
import tempfile
import shutil
import urllib.request
from zipfile import ZipFile
import processing
import time
import gc
from datetime import datetime, timedelta
directory_temporanea = ""                


class catasto_gml_merger:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'catasto_gml_merger_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Catasto_gml_merger')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('catasto_gml_merger', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/catasto_gml_merger/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'catasto_gml_merger'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Catasto_gml_merger'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        if self.first_start == True:
            self.first_start = False
            self.dlg = catasto_gml_mergerDialog()

        self.dlg.show()

            
        def log_message(msg):
            print(msg)
            QgsMessageLog.logMessage(msg, 'Elaborazione GML')
            self.dlg.text_log.append(msg)
            self.dlg.text_log.repaint()
            
        def collect_inputs():
            inputs = {}
            
            file_type = self.dlg.cb_file_type.currentText()
            inputs['file_type'] = file_type
            print(inputs['file_type'])
            
            inputs['main_folder'] = self.dlg.le_folder.filePath()
            print(inputs['main_folder'])
            
            inputs['url'] = self.dlg.le_url.text()
            print(inputs['url'])
            
            formats = {
                'GPKG': '.gpkg',
                'shp': '.shp',
                'GeoJSON': '.geojson'
            }

            format_name = self.dlg.cb_format.currentText()
            inputs['format_name'] = format_name
            inputs['output_extension'] = formats[format_name]
            print(inputs['output_extension'])
            
            if file_type in ['Mappe (MAP)', 'Entrambi']:

                map_output = self.dlg.le_map_output.filePath()                                      
                if not map_output: return None
                if not map_output.endswith(formats[format_name]):
                    map_output += formats[format_name]
                inputs['map_output'] = map_output
                print(inputs['map_output'])
            
            if file_type in ['Particelle (PLE)', 'Entrambi']:

                ple_output = self.dlg.le_ple_output.filePath()                                        
                if not ple_output: return None
                if not ple_output.endswith(formats[format_name]):
                    ple_output += formats[format_name]
                inputs['ple_output'] = ple_output
                print(inputs['ple_output'])

            if self.dlg.cb_load_layers.isChecked():
                inputs['load_layers'] =  'Sì'
            else:
                return None
            print(inputs['load_layers'])
            
            self.dlg.text_log.clear()
            
            return inputs

        def merge_files(source_folder, output_file, file_type, inputs):
            start_time = datetime.now()

            source_files = [
                os.path.join(source_folder, f)
                for f in os.listdir(source_folder)
                if f.endswith(".gml")
            ]

            if source_files:
                # Usa una directory temporanea specifica per evitare conflitti
                temp_dir = os.path.join(os.path.dirname(source_folder), "temp_processing")
                os.makedirs(temp_dir, exist_ok=True)
                temp_merge = os.path.join(temp_dir, f"temp_merge_{file_type}_{int(time.time())}.gpkg")

                merge_params = {
                    "LAYERS": source_files,
                    "CRS": None,
                    "OUTPUT": temp_merge,
                }

                log_message(f"Unione file {file_type}...")
                processing.run("native:mergevectorlayers", merge_params)

                # Chiudi esplicitamente i riferimenti ai layer che potrebbero utilizzare il file temporaneo
                project = QgsProject.instance()
                layers_to_remove = []
                for layer_id, layer in project.mapLayers().items():
                    if temp_merge in layer.source():
                        layers_to_remove.append(layer_id)
                
                for layer_id in layers_to_remove:
                    project.removeMapLayer(layer_id)
                
                # Forza il garbage collection
                gc.collect()
                time.sleep(0.5)

                # Gestione speciale per shapefile: assicurarsi che il percorso di output non abbia estensione
                # il processing algorithm aggiungerà automaticamente .shp
                if inputs['output_extension'] == '.shp':
                    if output_file.lower().endswith('.shp'):
                        output_file = output_file[:-4]  # Rimuovi l'estensione .shp
                    
                    # Assicurati che la directory esista
                    output_dir = os.path.dirname(output_file)
                    if not os.path.exists(output_dir):
                        os.makedirs(output_dir, exist_ok=True)

                filter_params = {
                    "INPUT": temp_merge,
                    "FIELDS": ["fid", "gml_id", "ADMINISTRATIVEUNIT"],
                    "OUTPUT": output_file,
                }

                log_message(f"Filtro attributi per {file_type}...")
                result = processing.run("native:retainfields", filter_params)
                
                # Aggiorna il percorso di output per i successivi riferimenti
                # Nel caso degli shapefile, result['OUTPUT'] conterrà il percorso corretto con estensione
                output_file = result['OUTPUT']

                # Ottimizzazione della generazione dei campi utilizzando operazioni in batch
                log_message(f"Aggiunta campo 'foglio' al layer {file_type}...")
                output_layer = QgsVectorLayer(output_file, f"{file_type}_Uniti", "ogr")
                
                if output_layer.isValid():
                    # Prepara tutti i campi da aggiungere in una singola operazione
                    fields_to_add = [QgsField("foglio", QVariant.String)]
                    if file_type == "PLE":
                        log_message("Aggiunta campo 'particella'...")
                        fields_to_add.append(QgsField("particella", QVariant.String))
                    
                    # Inizia la transazione per le modifiche in batch
                    output_layer.startEditing()
                    output_layer.dataProvider().addAttributes(fields_to_add)
                    output_layer.updateFields()
                    
                    # Ottieni gli indici una sola volta fuori dal ciclo
                    foglio_idx = output_layer.fields().indexFromName("foglio")
                    particella_idx = output_layer.fields().indexFromName("particella") if file_type == "PLE" else -1
                    gml_id_idx = output_layer.fields().indexFromName("gml_id")
                    
                    # Approccio a buffer per modifiche più veloci
                    changes_buffer = {}
                    
                    # Usa una singola passata per elaborare tutti i dati
                    for feature in output_layer.getFeatures():
                        feature_id = feature.id()
                        gml_id = feature[gml_id_idx]
                        changes_buffer[feature_id] = {}
                        
                        # Estrai foglio (posizioni 32-36)
                        if len(gml_id) > 36:
                            foglio = gml_id[32:36]
                            changes_buffer[feature_id][foglio_idx] = foglio
                        
                        # Estrai particella per PLE (dalla posizione 39 in poi)
                        if file_type == "PLE" and particella_idx >= 0 and len(gml_id) > 39:
                            particella = gml_id[39:]
                            changes_buffer[feature_id][particella_idx] = particella
                    
                    # Applica tutte le modifiche in batch
                    batch_size = 5000  # Dimensione del batch per evitare operazioni troppo grandi
                    batch_count = 0
                    for feature_id, attrs in changes_buffer.items():
                        for field_idx, value in attrs.items():
                            output_layer.changeAttributeValue(feature_id, field_idx, value)
                        
                        batch_count += 1
                        if batch_count % batch_size == 0:
                            # Aggiorna periodicamente l'interfaccia per mostrare progresso
                            QCoreApplication.processEvents()
                    
                    # Finalizza le modifiche e controlla errori
                    success = output_layer.commitChanges()
                    if success:
                        log_message(f"Campi calcolati correttamente per il layer {file_type}")
                    else:
                        log_message(f"ERRORE: Impossibile aggiornare i campi per il layer {file_type}")
                        log_message(str(output_layer.commitErrors()))
                else:
                    log_message(f"ERRORE: Il layer di output {file_type} non è valido")

                # Pulizia risorse temporanee in modo più robusto
                try:
                    # Prima rilascia i riferimenti QGIS al file
                    for layer_id, layer in list(QgsProject.instance().mapLayers().items()):
                        if temp_merge in layer.source():
                            QgsProject.instance().removeMapLayer(layer_id)
                    
                    # Libera memoria e dai tempo al sistema
                    output_layer = None
                    gc.collect()
                    time.sleep(1)
                    
                    # Ora prova a cancellare il file temporaneo
                    if os.path.exists(temp_merge):
                        os.remove(temp_merge)
                        log_message(f"File temporaneo rimosso")
                    
                    # Rimuovi anche la directory temporanea se vuota
                    if len(os.listdir(temp_dir)) == 0:
                        os.rmdir(temp_dir)
                except Exception as e:
                    log_message(f"Nota: Impossibile rimuovere alcuni file temporanei: {str(e)}")
                    log_message("<span style='color:#FF8C00;font-weight:bold;'>I file temporanei verranno rimossi alla chiusura di QGIS</span>")
                
                # Carica i layer se richiesto
                if inputs["load_layers"]:
                    # Ottieni il nome del file senza percorso e estensione
                    file_name = os.path.basename(output_file)
                    base_name = os.path.splitext(file_name)[0]
                    
                    merged_layer = QgsVectorLayer(output_file, base_name, "ogr")
                    if merged_layer.isValid():
                        QgsProject.instance().addMapLayer(merged_layer)
                        log_message(f"Layer {base_name} caricato in QGIS")
                    else:
                        log_message(f"ERRORE: Impossibile caricare il layer {base_name}")
                            
                end_time = datetime.now()
                
                return end_time - start_time

            return None

        def process_gml_files():

            global directory_temporanea

            inputs = collect_inputs()
            if not inputs:
                log_message("Operazione annullata")
                return
                    
            try:
                temp_dir = tempfile.mkdtemp()

                if "map_output" in inputs:
                    map_folder = os.path.join(temp_dir, "map_files")
                    os.makedirs(map_folder, exist_ok=True)
                if "ple_output" in inputs:
                    ple_folder = os.path.join(temp_dir, "ple_files")
                    os.makedirs(ple_folder, exist_ok=True)

                log_message(f"Cartelle create in: {temp_dir}\n")
            finally:
                log_message("Download del file zip...\n")
                zip_path = os.path.join(temp_dir, "downloaded.zip")
                urllib.request.urlretrieve(inputs["url"], zip_path)

                log_message("Estrazione province...\n")
                with ZipFile(zip_path, "r") as zip_ref:
                    zip_ref.extractall(temp_dir)
                province_zips = [
                    f
                    for f in os.listdir(temp_dir)
                    if f.endswith(".zip") and f != "downloaded.zip"
                ]
                for prov_zip in province_zips:
                    log_message(f"Elaborazione provincia: {prov_zip}\n")
                    prov_path = os.path.join(temp_dir, prov_zip)
                    prov_dir = os.path.join(temp_dir, os.path.splitext(prov_zip)[0])

                    with ZipFile(prov_path, "r") as zip_ref:
                        zip_ref.extractall(prov_dir)
                    comuni_zips = [
                        f for f in os.listdir(prov_dir) if f.endswith(".zip")
                    ]

                                                                                                 
                    for com_zip in comuni_zips:
                        log_message(f"Elaborazione comune: {com_zip}")
                        com_path = os.path.join(prov_dir, com_zip)
                        com_dir = os.path.join(prov_dir, os.path.splitext(com_zip)[0])
                        with ZipFile(com_path, "r") as zip_ref:
                            zip_ref.extractall(com_dir)

                ple_count = map_count = 0
                for root, dirs, files in os.walk(temp_dir):
                    for file in files:
                        if file.endswith(".gml"):
                            file_path = os.path.join(root, file)
                            if "ple_output" in inputs and "_ple" in file.lower():
                                shutil.move(file_path, os.path.join(ple_folder, file))
                                ple_count += 1
                            elif "map_output" in inputs and "_map" in file.lower():
                                shutil.move(file_path, os.path.join(map_folder, file))
                                map_count += 1
                        
                log_message(f"\nFile trovati: {ple_count} PLE, {map_count} MAP")

                processing_times = {}

                if inputs["file_type"] in ["Mappe (MAP)", "Entrambi"]:
                    log_message("\nMerging MAP\n")
                    map_time = merge_files(
                        map_folder, inputs["map_output"], "MAP", inputs
                    )
                    if map_time:
                        processing_times["MAP"] = map_time

                if inputs["file_type"] in ["Particelle (PLE)", "Entrambi"]:
                    log_message("\nMerging PLE\n")
                    ple_time = merge_files(
                        ple_folder, inputs["ple_output"], "PLE", inputs
                    )
                    if ple_time:
                        processing_times["PLE"] = ple_time 

                log_message("\nElaborazione completata!")
                if "map_output" in inputs:
                    log_message(f"File MAP salvato in: {inputs['map_output']}")
                if "ple_output" in inputs:
                    log_message(f"File PLE salvato in: {inputs['ple_output']}")
                        
                log_message("\nTempi di elaborazione:")
                for file_type, proc_time in processing_times.items():
                    if proc_time:
                        minutes = proc_time.total_seconds() / 60
                        log_message(f"Merge {file_type}: {minutes:.2f} minuti")
            directory_temporanea = temp_dir


        def pulisci_temporanea():
            global directory_temporanea
            dir_path = directory_temporanea

            if not dir_path or not os.path.exists(dir_path):
                log_message("Nessuna directory temporanea da pulire")
                return
                
            # Libera tutti i layer che potrebbero usare file nella directory temporanea
            for layer_id, layer in list(QgsProject.instance().mapLayers().items()):
                if dir_path in layer.source():
                    QgsProject.instance().removeMapLayer(layer_id)
            
            # Forza garbage collection
            gc.collect()
            time.sleep(1)
            
            try:
                for root, dirs, files in os.walk(dir_path, topdown=False):
                    for file in files:
                        try:
                            os.remove(os.path.join(root, file))
                        except:
                            log_message(f"Impossibile rimuovere {file}")
                
                shutil.rmtree(dir_path)
                log_message(f"Directory {dir_path} rimossa correttamente")
            except OSError as e:
                log_message(f"\nErrore nella pulizia: {str(e)}")
                log_message("Alcuni file temporanei verranno rimossi alla chiusura di QGIS")

            # Resetta l'interfaccia
            self.dlg.le_folder.setFilePath("")
            self.dlg.le_map_output.setFilePath("")
            self.dlg.le_ple_output.setFilePath("")
            self.dlg.cb_file_type.setCurrentIndex(0)
            self.dlg.cb_format.setCurrentIndex(0)
            self.dlg.cb_region.setCurrentIndex(0)
            self.dlg.le_url.clear()
            self.dlg.text_log.clear()
            
            self.dlg.hide()

        def url_update():
            self.dlg.le_url.setText("https://wfs.cartografia.agenziaentrate.gov.it/inspire/wfs/GetDataset.php?dataset=" + self.dlg.cb_region.currentText() + ".zip")
            pass       
            
        self.dlg.cb_region.currentIndexChanged.connect(url_update)                                                          
        self.dlg.btn_process.clicked.connect(process_gml_files)
        self.dlg.btn_close.clicked.connect(pulisci_temporanea)


class ProgressManager:
    def __init__(self, dialog, total_steps):
        self.dialog = dialog
        self.total = total_steps
        self.current = 0
        self.dialog.progressBar.setMaximum(total_steps)
        self.dialog.progressBar.setValue(0)
    
    def step(self, message=None):
        self.current += 1
        self.dialog.progressBar.setValue(self.current)
        if message:
            log_message(message)
        QCoreApplication.processEvents()  # Mantiene l'interfaccia reattiva
